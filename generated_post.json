{
  "title": "ThePrimeagen/99：当 Neovim 遇上 AI 副驾驶，代码编辑进入“心流”模式 🤖⚡",
  "content": "ThePrimeagen/99：当 Neovim 遇上 AI 副驾驶，代码编辑进入“心流”模式 🤖⚡\n\n<p>想象一下这个场景：深夜，你正在与一段复杂的重构代码搏斗。你需要在多个文件间跳转，理解上下文，修改函数签名，更新调用点。你的手在键盘和鼠标间来回切换，思绪不断被机械的操作打断。你渴望的是一种“心流”状态——让想法直接转化为代码，中间没有任何摩擦。今天推荐的 <a href=\"https://github.com/ThePrimeagen/99\">ThePrimeagen/99</a>，正是为了终结这种摩擦而生。它不是一个简单的代码补全插件，而是一个深度集成在 Neovim 中的 AI 智能体，旨在重新定义我们与编辑器的交互方式。</p>\n\n<h2 id=\"the-problem-we-face\">我们面临的困境：编辑器 vs. 思考流 🧠</h2>\n<p>现代开发者工具链已经非常强大，但一个根本的矛盾依然存在：我们的思维是连续、抽象且高速的，而操作编辑器（即使是 Vim）却是一系列离散、具体且相对缓慢的命令。当你想到“把这个函数提取出来，并更新所有调用者”时，你的大脑已经完成了这个“意图”，但你的手却需要执行几十个按键动作来实现它。</p>\n<p>现有的 AI 编码助手，如 GitHub Copilot，主要解决了“代码生成”的问题。它们在你输入时提供建议，很棒。但它们通常停留在“建议”层面，你需要接受、修改、调整。它们很少能理解你更宏观的编辑意图，也无法代表你执行一系列复杂的编辑器操作。你的思维仍然需要频繁地“降维”到编辑器操作层面。</p>\n<blockquote>\n<p>“99 的目标不是成为另一个补全引擎，而是成为一个能够理解你的意图并代表你在 Neovim 中执行复杂任务的智能体。” —— 项目理念</p>\n</blockquote>\n\n<h2 id=\"what-is-99\">99 是什么？Neovim 的“意图执行引擎” 🛠️</h2>\n<p>简单来说，ThePrimeagen/99 是一个运行在 Neovim 内部的 AI 智能体（Agent）。它的核心创新在于将大型语言模型（LLM）的能力与 Neovim 强大的编辑器和 Lua API 直接绑定。它不仅能生成代码片段，更能<strong>理解你的自然语言指令，并将其转化为一系列精准的 Neovim 操作</strong>。</p>\n<p>你可以把它理解为 Neovim 的一个超级插件，它赋予了你的编辑器“理解”和“执行”的能力。你告诉它“要做什么”，它来思考“怎么做”，并替你完成所有繁琐的按键和命令。</p>\n\n<h2 id=\"core-mechanism\">核心机制：从自然语言到编辑器动作的魔法 ⚙️</h2>\n<p>99 的工作流程可以概括为“感知-思考-行动”循环，这与 AI 智能体的通用范式一致，但完全聚焦于代码编辑上下文。</p>\n<h3 id=\"perception-context\">1. 感知：丰富的上下文收集</h3>\n<p>当你向 99 发出指令时（例如通过命令模式：<code>:99 Refactor this function to be pure</code>），它会自动收集当前编辑会话的丰富上下文：</p>\n<ul>\n<li><strong>当前文件内容</strong>及光标位置。</li>\n<li><strong>相关文件</strong>（通过 LSP 或模糊查找）。</li>\n<li><strong>项目结构</strong>和版本控制状态（如 Git diff）。</li>\n<li><strong>Neovim 的状态</strong>（打开的缓冲区、窗口布局等）。</li>\n</ul>\n<p>这些上下文被精心构造后，发送给配置的 LLM（如 OpenAI GPT、Claude 或本地模型）。</p>\n<h3 id=\"thinking-planning\">2. 思考与规划：生成可执行的“行动计划”</h3>\n<p>这是 99 的魔法所在。LLM 接收指令和上下文后，不会直接返回代码块，而是返回一个<strong>由特定操作组成的计划</strong>。这些操作是 99 定义的一套高级或低级编辑器动作。</p>\n<p>例如，对于“提取函数”的指令，模型可能生成如下计划（伪代码表示）：</p>\n<pre><code class=\"language-lua\">1. SELECT_VISUAL: 从第12行第5列到第20行第10列。\n2. YANK: 复制选中内容到寄存器 <code>a</code>。\n3. CREATE_NEW_BUFFER: 在垂直分割窗口中。\n4. PASTE: 将寄存器 <code>a</code> 内容粘贴到新缓冲区。\n5. LSP_RENAME: 将新函数命名为 <code>calculate_optimized_value</code>。\n6. FIND_REFERENCES: 查找原函数的调用点。\n7. LOOP_REFERENCES:\n   - 跳转到每个调用点。\n   - REPLACE_TEXT: 将调用替换为对新函数的调用并传入正确参数。\n8. SAVE_ALL_FILES.\n</code></pre>\n<h3 id=\"action-execution\">3. 行动：安全、可观察地执行</h3>\n<p>99 的“执行引擎”会解析这个计划，并将其转化为对 Neovim Lua API 的真实调用。执行过程通常是：</p>\n<ul>\n<li><strong>逐步进行</strong>：你可以看到它在你的编辑器里“操作”，光标跳动，文本被修改，窗口打开或关闭。</li>\n<li><strong>可中断</strong>：随时可以停止执行。</li>\n<li><strong>安全考虑</strong>：对于重大操作（如批量替换），可能会请求确认，或者优先在非保存的缓冲区中进行，让你有检查的机会。</li>\n</ul>\n\n<h2 id=\"scenario-showcase\">场景展示：告别繁琐，拥抱意图 🚀</h2>\n<p>让我们看几个具体的例子，感受 99 如何改变工作流：</p>\n<h3 id=\"scenario-1-complex-refactoring\">场景一：复杂重构</h3>\n<p><strong>旧方式</strong>：发现一个函数做了太多事情。你需要：1) 思考如何拆分；2) 手动选择代码块，剪切；3) 创建新文件或找到合适位置；4) 粘贴并定义新函数；5) 修改原函数，调用新函数；6) 查找所有调用点，更新参数传递。极易出错且枯燥。</p>\n<p><strong>使用 99</strong>：选中函数体，输入 <code>:99 Extract this into a separate utility function, handle error cases.</code>。接下来，你可以倒杯咖啡，看着 99 帮你完成所有步骤，你只需要在最后审查结果。</p>\n<h3 id=\"scenario-2-boilerplate-generation\">场景二：样板代码生成（带上下文）</h3>\n<p><strong>旧方式</strong>：需要为一个新的 API 端点编写控制器、服务层和 DTO。要么手动敲，要么用代码片段工具，但需要调整导入、命名、类型等。</p>\n<p><strong>使用 99</strong>：在项目根目录，打开一个临时缓冲区，输入：<code>:99 Based on the existing <code>User</code> module, create a new <code>Product</code> module with similar CRUD structure. Include validation and logging.</code>。99 会分析现有的 <code>User</code> 模块结构，理解你的项目约定，然后在正确的位置生成一整套风格一致、导入正确的 <code>Product</code> 模块文件。</p>\n<h3 id=\"scenario-3-debugging-assistant\">场景三：交互式调试助手</h3>\n<p>遇到一个棘手的 Bug。你可以对 99 说：<code>:99 Look at the stack trace in the terminal buffer and the code around line 45 in <code>service.py</code>. Suggest a fix and apply it if it looks good.</code> 99 会分析终端输出和你的代码，提出修复方案，并<strong>征求你的同意后</strong>直接应用修复。</p>\n\n<h2 id=\"setup-and-customization\">配置与定制：打造你的专属智能体 ⚙️🎨</h2>\n<p>99 基于 Neovim 的灵活性，提供了丰富的配置选项：</p>\n<pre><code class=\"language-lua\">-- 在 Neovim 配置中 (init.lua 或 plugins/99.lua)\nrequire('99').setup({\n  -- 选择你的 AI 大脑\n  llm_provider = \"openai\", -- 或 \"claude\", \"ollama\" (本地)\n  openai_api_key = os.getenv(\"OPENAI_API_KEY\"),\n  model = \"gpt-4\", -- 模型选择\n\n  -- 控制智能体的“性格”和能力\n  max_steps_per_plan = 20, -- 防止计划过于冗长\n  enable_code_execution = false, -- 谨慎开启：是否允许执行生成的代码\n  confirmation_threshold = \"high_risk\", -- 何时需要用户确认\n\n  -- 自定义工具：为智能体增加新能力！\n  custom_tools = {\n    {\n      name = \"run_project_test\",\n      description = \"Run the project's specific test suite\",\n      func = function()\n        vim.cmd(\"TermExec cmd='npm test'\")\n      end\n    }\n  }\n})\n</code></pre>\n<p>你可以教 99 理解你项目的特定命令、工作流和代码规范，让它真正成为你团队的一员。</p>\n\n<h2 id=\"challenges-and-future\">挑战与未来：人机协作的新范式 💡</h2>\n<p>当然，这样的工具也带来新的挑战和思考：</p>\n<ul>\n<li><strong>控制感 vs. 自动化</strong>：完全交出控制权可能令人不安。99 的设计强调“可观察性”和“可中断性”，确保你始终是主导者。</li>\n<li><strong>成本与延迟</strong>：频繁调用 LLM API 可能产生费用和延迟。优化上下文长度、使用更高效的模型或本地模型是关键。</li>\n<li><strong>错误的代价</strong>：AI 可能会做出错误的编辑。因此，与版本控制系统（Git）的深度集成、创建临时备份、以及清晰的撤销机制至关重要。</li>\n</ul>\n<p>项目的未来令人兴奋。想象一下：智能体之间可以协作（一个负责前端，一个负责后端）；智能体可以学习你的个人编辑习惯；甚至可以将整个开发任务（“实现登录功能”）描述给它，看着它从创建组件到编写 API 再到配置数据库，一气呵成。</p>\n\n<h2 id=\"conclusion\">总结：不仅仅是工具，是思维模式的延伸 🌟</h2>\n<p>ThePrimeagen/99 的出现，标志着开发者工具从“增强操作效率”向“弥合思维与实现之间鸿沟”的范式转变。它不再仅仅是一个帮你更快打字的工具，而是一个能理解你的意图、并代表你与复杂代码库交互的合作伙伴。</p>\n<p>它最适合那些已经深度使用 Neovim、厌倦了重复性编辑操作、并渴望将更多认知资源投入到真正创造性问题解决中的开发者。这不仅仅是关于更快地编码，更是关于更流畅地思考，更持久地保持“心流”状态。</p>\n<p>如果你已经准备好，将你的编辑器从一个被动的工具，升级为一个主动的、懂你的协作者，那么是时候将 /99 加入你的工具箱了。未来的编码，或许就是这样：你说出想法，编辑器帮你实现。🚀</p>",
  "repo_info": {
    "name": "ThePrimeagen/99",
    "url": "https://github.com/ThePrimeagen/99",
    "desc": "Neovim AI agent done right",
    "stars": "2,312",
    "date": "2026-02-01"
  },
  "generated_at": "2026-02-01T02:56:53.517428"
}